-- ====================================================================
--      SCRIPT DE BASE DE DATOS PACIFICOWEB (VERSIÓN CONSOLIDADA)
-- ====================================================================
-- Este script contiene el esquema completo y actualizado.
-- Ejecútalo en un entorno limpio de Supabase para configurar la BD.

-- --------------------------------------------------------------------
-- TABLA 1: USUARIOS
-- --------------------------------------------------------------------
CREATE TABLE public.usuarios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  uuid UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  supabase_auth_id UUID, -- Columna para mapear de forma segura a auth.users durante la migración
  nombre TEXT,
  correo TEXT UNIQUE NOT NULL,
  -- password_hash ya no es necesario, se migró a Supabase Auth
  role TEXT DEFAULT 'user' NOT NULL,
  status TEXT DEFAULT 'temporary' NOT NULL, -- Estados: temporary, active, suspended
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  actualizado_at TIMESTAMPTZ
);
COMMENT ON TABLE public.usuarios IS 'Perfiles de usuario extendidos que se sincronizan con auth.users.';

-- --------------------------------------------------------------------
-- TABLA 2: PLANES
-- --------------------------------------------------------------------
CREATE TABLE public.planes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre TEXT NOT NULL UNIQUE,
    precio NUMERIC(10, 2) NOT NULL,
    detalles TEXT
);
COMMENT ON TABLE public.planes IS 'Define los tipos de suscripción disponibles (ej. vendedor_diamante).';

-- --------------------------------------------------------------------
-- TABLA 3: CONTRATOS
-- --------------------------------------------------------------------
CREATE TABLE public.contratos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_uuid UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    plan_id BIGINT NOT NULL REFERENCES public.planes(id),
    fecha_inicio TIMESTAMPTZ DEFAULT now() NOT NULL,
    fecha_expiracion TIMESTAMPTZ NOT NULL,
    activo BOOLEAN DEFAULT true NOT NULL
);
COMMENT ON TABLE public.contratos IS 'Vincula a un usuario con un plan y una fecha de expiración.';

-- --------------------------------------------------------------------
-- TABLA 4: STORES (Tiendas) - VERSIÓN MEJORADA
-- --------------------------------------------------------------------
CREATE TABLE public.stores (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id BIGINT NOT NULL UNIQUE REFERENCES public.usuarios(id) ON DELETE CASCADE,
  nombre VARCHAR(255) NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  activa BOOLEAN DEFAULT FALSE NOT NULL,
  descripcion TEXT,
  logo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  
  -- Columnas JSONB específicas (reemplazan la columna genérica 'data')
  buy_text TEXT,
  cards JSONB DEFAULT '[]'::jsonb,
  faqs JSONB DEFAULT '[]'::jsonb,
  colors JSONB DEFAULT '{}'::jsonb,
  main_url TEXT,
  gallery_urls JSONB DEFAULT '[]'::jsonb,
  video_url TEXT,
  variants JSONB DEFAULT '[]'::jsonb,
  whatsapp JSONB DEFAULT '{}'::jsonb,
  emails JSONB DEFAULT '[]'::jsonb,
  addresses JSONB DEFAULT '[]'::jsonb,
  animation JSONB DEFAULT '{}'::jsonb,
  sections JSONB DEFAULT '[]'::jsonb
);
COMMENT ON TABLE public.stores IS 'Almacena la configuración y datos de las tiendas de los usuarios.';

-- --------------------------------------------------------------------
-- TABLA 5: PEDIDOS
-- --------------------------------------------------------------------
CREATE TABLE public.pedidos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    customer_name TEXT NOT NULL,
    order_date TIMESTAMPTZ NOT NULL,
    products JSONB,
    total_price NUMERIC(10, 2),
    total_weight NUMERIC(10, 2),
    raw_message TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.pedidos IS 'Almacena las órdenes generadas por los usuarios para sus clientes.';

-- --------------------------------------------------------------------
-- ÍNDICES PARA STORES (Optimización de consultas JSONB)
-- --------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS stores_cards_gin_idx ON public.stores USING GIN (cards);
CREATE INDEX IF NOT EXISTS stores_faqs_gin_idx ON public.stores USING GIN (faqs);
CREATE INDEX IF NOT EXISTS stores_variants_gin_idx ON public.stores USING GIN (variants);
CREATE INDEX IF NOT EXISTS stores_gallery_urls_gin_idx ON public.stores USING GIN (gallery_urls);
CREATE INDEX IF NOT EXISTS stores_whatsapp_gin_idx ON public.stores USING GIN (whatsapp);
CREATE INDEX IF NOT EXISTS stores_emails_gin_idx ON public.stores USING GIN (emails);
CREATE INDEX IF NOT EXISTS stores_addresses_gin_idx ON public.stores USING GIN (addresses);
CREATE INDEX IF NOT EXISTS stores_animation_gin_idx ON public.stores USING GIN (animation);
CREATE INDEX IF NOT EXISTS stores_sections_gin_idx ON public.stores USING GIN (sections);

-- --------------------------------------------------------------------
-- LÓGICA DE TRIGGERS (Función de Slug Único para STORES)
-- --------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.generate_unique_store_slug()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  base text;
  candidate text;
  i integer := 1;
  lock_key bigint;
BEGIN
  IF NEW.slug IS NULL OR btrim(NEW.slug) = '' THEN
    base := lower(regexp_replace(regexp_replace(COALESCE(NEW.nombre, ''), '[^a-zA-Z0-9]+', '-', 'g'), '(^-+|-+$)', '', 'g'));
  ELSE
    base := lower(regexp_replace(COALESCE(NEW.slug, ''), '[^a-zA-Z0-9]+', '-', 'g'));
    base := regexp_replace(base, '(^-+|-+$)', '', 'g');
  END IF;

  IF base = '' THEN
    base := 'store';
  END IF;

  lock_key := ('x' || substr(md5(base),1,16))::bit(64)::bigint;
  PERFORM pg_advisory_xact_lock(lock_key);

  candidate := base;
  LOOP
    EXIT WHEN NOT EXISTS (
      SELECT 1 FROM public.stores
      WHERE slug = candidate
        AND id IS DISTINCT FROM NEW.id
    );
    candidate := base || '-' || i;
    i := i + 1;
  END LOOP;

  NEW.slug := candidate;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_generate_unique_store_slug
  BEFORE INSERT OR UPDATE ON public.stores
  FOR EACH ROW
  EXECUTE FUNCTION public.generate_unique_store_slug();

-- --------------------------------------------------------------------
-- VISTA (VIEW) para unir usuarios y planes
-- --------------------------------------------------------------------
CREATE OR REPLACE VIEW public.vw_usuarios_planes AS
SELECT
    u.id AS usuario_id,
    u.uuid AS usuario_uuid,
    u.nombre,
    u.correo,
    u.status,
    u.created_at AS creado_at, -- Columna añadida
    c.id AS contrato_id,
    p.nombre AS plan,
    c.fecha_inicio,
    c.fecha_expiracion,
    c.activo
FROM public.usuarios u
LEFT JOIN public.contratos c ON u.uuid = c.usuario_uuid
LEFT JOIN public.planes p ON c.plan_id = p.id;

COMMENT ON VIEW public.vw_usuarios_planes IS 'Vista para consultar fácilmente los datos del plan de cada usuario.';

-- --------------------------------------------------------------------
-- FUNCIONES RPC (Remote Procedure Calls)
-- --------------------------------------------------------------------

-- Función 1: Crear usuario y contrato (transaccional)
CREATE OR REPLACE FUNCTION public.create_user_and_contract(p_nombre text, p_correo text, p_password_hash text, p_plan_nombre text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  new_user_id uuid;
  selected_plan_id bigint;
  contract_duration_months int;
BEGIN
  -- Esta función asume que el usuario de auth ya fue creado y esta función sincroniza el resto.
  new_user_id := auth.uid();

  INSERT INTO public.usuarios (uuid, nombre, correo, password_hash, status, role)
  VALUES (new_user_id, p_nombre, p_correo, p_password_hash, 'temporary', 'user');

  SELECT id INTO selected_plan_id FROM public.planes WHERE nombre = p_plan_nombre;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Plan no encontrado: %', p_plan_nombre;
  END IF;

  contract_duration_months := 3;

  INSERT INTO public.contratos (usuario_uuid, plan_id, fecha_inicio, fecha_expiracion, activo)
  VALUES (new_user_id, selected_plan_id, now(), now() + (contract_duration_months || ' months')::interval, true);
END;
$$;

-- Función 2: Obtener estadísticas de registro
CREATE OR REPLACE FUNCTION public.get_registration_stats()
RETURNS TABLE(registration_date date, user_count bigint) LANGUAGE sql AS $$
  SELECT created_at::date AS registration_date, COUNT(*) AS user_count
  FROM public.usuarios
  GROUP BY registration_date
  ORDER BY registration_date ASC;
$$;

-- Función 3: Obtener resumen para un usuario
CREATE OR REPLACE FUNCTION public.get_summary(p_user_id uuid)
RETURNS TABLE(total_revenue numeric, total_orders bigint) LANGUAGE sql AS $$
  SELECT
    COALESCE(SUM(total_price), 0) AS total_revenue,
    COALESCE(COUNT(id), 0) AS total_orders
  FROM public.pedidos
  WHERE user_id = p_user_id;
$$;

-- --------------------------------------------------------------------
-- POLÍTICAS DE SEGURIDAD (Row Level Security - RLS)
-- --------------------------------------------------------------------
ALTER TABLE public.usuarios ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.planes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contratos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pedidos ENABLE ROW LEVEL SECURITY;

-- Políticas para USUARIOS
CREATE POLICY "Los usuarios pueden ver su propio perfil." ON public.usuarios FOR SELECT USING (auth.uid() = uuid);
CREATE POLICY "Los usuarios pueden actualizar su propio perfil." ON public.usuarios FOR UPDATE USING (auth.uid() = uuid);

-- Políticas para STORES (Versión Mejorada)
CREATE POLICY stores_public_select ON public.stores FOR SELECT USING (true);
CREATE POLICY stores_insert_owner ON public.stores FOR INSERT WITH CHECK (auth.uid() = (SELECT uuid FROM public.usuarios WHERE id = usuario_id));
CREATE POLICY stores_update_owner ON public.stores FOR UPDATE USING (auth.uid() = (SELECT uuid FROM public.usuarios WHERE id = usuario_id)) WITH CHECK (auth.uid() = (SELECT uuid FROM public.usuarios WHERE id = usuario_id));

-- Políticas para PLANES (lectura pública)
CREATE POLICY "Los planes son visibles para todos." ON public.planes FOR SELECT USING (true);

-- Políticas para CONTRATOS
CREATE POLICY "Los usuarios pueden ver sus propios contratos." ON public.contratos FOR SELECT USING (auth.uid() = usuario_uuid);

-- Políticas para PEDIDOS
CREATE POLICY "Los usuarios pueden gestionar sus propios pedidos." ON public.pedidos FOR ALL USING (auth.uid() = user_id);


-- FIN DEL SCRIPT --
